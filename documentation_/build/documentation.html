<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Kurz" />
  <title>IMU-Daten einer Trajektorie</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f4f4f4; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #006400; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">IMU-Daten einer Trajektorie</h1>
<p class="author">Christoph Kurz</p>
</header>

<p>[[TOC]]</p>
<h1 id="anwendung">Anwendung</h1>
<p>Im Folgenden soll ein Matlab-Tool vorgestellt werden, das es ermÃ¶glicht, anhand einer vorgegebenen Trajektorie und einer vorgegebenen Orientierung die Ausgangsdaten einer IMU (Inertialen Messeinheit) zu simulieren. Die Vorgabe der Trajektorie <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{s}(t)</annotation></semantics></math> und der Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\varphi}(t)</annotation></semantics></math> soll mithilfe einer Funktion (zur symbolischen Berechnung) und mithilfe eines Vektors (zur nummerischen Berechnung) mÃ¶glich sein:</p>
<p>Vorgabe mithilfe von Funktionen:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb1-1" title="1"><span class="co">% Trajektorie als Funktion</span></a>
<a class="sourceLine" id="cb1-2" title="2">sx = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-3" title="3">sy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-4" title="4">sz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*<span class="fl">3</span>*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">% Orientierung als Funktion</span></a>
<a class="sourceLine" id="cb1-7" title="7">phix = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb1-8" title="8">phiy = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb1-9" title="9">phiz = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a></code></pre></div>
<p>Vorgabe mithilfe von Vektoren:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb2-1" title="1"><span class="co">% Zeit Vektor</span></a>
<a class="sourceLine" id="cb2-2" title="2">t = (<span class="fl">0</span> : <span class="fl">0.01</span> : <span class="fl">5</span>); <span class="co">% s</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">% Trajektorie als Vektor</span></a>
<a class="sourceLine" id="cb2-5" title="5">sx = (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-6" title="6">sy = (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-7" title="7">sz = (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*<span class="fl">3</span>*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">% Orientierung als Vektor</span></a>
<a class="sourceLine" id="cb2-10" title="10">phix = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb2-11" title="11">phiy = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb2-12" title="12">phiz = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a></code></pre></div>
<p>Entlang dieser Vorgegebenen Trajektorie bewegt sich der Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> eines starren KÃ¶rpers. Die Inertiale Messeinheit ist dabei im Abstand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>r</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math> vom Schwerpunkt entfernt.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb3-1" title="1">r = [-<span class="fl">75e-3</span>, -<span class="fl">75e-3</span>, <span class="fl">25e-3</span>]; <span class="co">% m</span></a></code></pre></div>
<p>Um dies zu Verdeutlichen wird in der Abbildung  die oben definierte Trajektorie abgebildet.</p>
<figure>
<embed src="img/01_trajectory/trajectory.pdf" /><figcaption>Beispiel einer Trajektorie mit einer IMU </figcaption>
</figure>
<p>Hierbei wird der starre KÃ¶rper als rotes Dreieck dargestellt das sich entlang der Trajektorie fortbewegt. Die Orientierung des starren KÃ¶rpers wurde so gewÃ¤hlt, dass er sich entlang des Tangentialvektors der Trajektorie ausrichtet. Der Schwerpunkt und die Position der IMU werden mit einem gelben und violetten Punkt markiert.</p>

<h1 id="grundlagen">Grundlagen</h1>
<p>Bevor nÃ¤her auf die Algorithmen eingegangen wird, werdend die Grundlagen beschrieben, die im Weiteren von Bedeutung sind. Hierbei sind der Weg <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math> und die Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math> von Bedeutung. Daraus ergeben sich 6 Freiheitsgrade, damit Position und Lage eines KÃ¶rpers im Raum beschrieben werden kann. Weiters sind die folgenden Ableitungen dieser GrÃ¶ÃŸen von Bedeutung:</p>
<ul>
<li>die Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo>=</mo><mover><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><mo accent="true">Ì‡</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v} = \dot{\vec{s}}</annotation></semantics></math></li>
<li>die Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo>=</mo><mover><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo accent="true">Ì‡</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\omega} = \dot{\vec{\varphi}}</annotation></semantics></math></li>
<li>die lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">âƒ—</mo></mover><mo>=</mo><mover><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo accent="true">Ì‡</mo></mover></mrow><annotation encoding="application/x-tex">\vec{a} = \dot{\vec{v}}</annotation></semantics></math></li>
<li>die Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo>=</mo><mover><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo accent="true">Ì‡</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\alpha} = \dot{\vec{\omega}}</annotation></semantics></math></li>
</ul>
<p>Wobei <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mrow><mo stretchy="false" form="prefix">(</mo><mo>â‹…</mo><mo stretchy="false" form="postfix">)</mo></mrow><mo accent="true">Ì‡</mo></mover><annotation encoding="application/x-tex">\dot{(\cdot)}</annotation></semantics></math> die zeitliche Ableitung kennzeichnet. Die beschriebenen GrÃ¶ÃŸen lassen sich in lineare GrÃ¶ÃŸen (Weg <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>, Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math>, lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>a</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{a}</annotation></semantics></math>) und in DrehgrÃ¶ÃŸen (Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math>, Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{\omega}</annotation></semantics></math>, Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{\alpha}</annotation></semantics></math>) unterteilen.</p>
<h2 id="orientierung-im-dreidimensionalen-raum-mithilfe-von-euler-winkeln-und-drehmatrizen">Orientierung im dreidimensionalen Raum mithilfe von Euler-Winkeln und Drehmatrizen</h2>
<p>Um die Orientierung von KÃ¶rpern zu beschreiben werden Euler-Winkel verwendet. Aus diesen kÃ¶nnen Drehmatrizen gewonnen werden, die eine Rotation des Koordinatensystem (eine Ã„nderung der Orientierung) ermÃ¶glichen. Dazu mÃ¼ssen verschiedenen Koordinatensysteme eingefÃ¼hrt werden:</p>
<ul>
<li>Inertialsystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>â„•</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></li>
<li>KÃ¶rperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math></li>
</ul>
<p>Das Inertialsystem wird nach ENU-Konvention definiert. ENU bedeutet East, North, Up (also Osten, Norden, oben) und beschreibt die Richtung der Koordinaten-Achsen (Osten <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">= x</annotation></semantics></math>, Norden <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">= y</annotation></semantics></math> und oben <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">= z</annotation></semantics></math>). Die KÃ¶rperkoordinatensysteme beschreibt das Koordinatensystem des starren KÃ¶rpers.</p>
<h3 id="euler-winkel">Euler-Winkel</h3>
<p>Die Euler-Winkel beschreiben die Drehlage/Orientierung eines KÃ¶rpers durch 3 Winkel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\varphi_x</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\varphi_y</annotation></semantics></math> und <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\varphi_z</annotation></semantics></math> der jeweiligen Achse. Zusammen beschreiben sie den Vektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math>: <span id="eq:euler_winkel" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>Ï†</mi><mi>x</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>Ï†</mi><mi>y</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>Ï†</mi><mi>z</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
    \vec{\varphi} = 
    \begin{bmatrix}
        \varphi_x \\
        \varphi_y \\
        \varphi_z \\
    \end{bmatrix}
</annotation></semantics></math><span class="eqnos-number">(1)</span></span>  Es wird unterschieden zwischen den klassischen Euler-Winkeln und den Tait-Bryan-Winkeln, wobei diese wieder in unterschiedliche Konventionen eingeteilt werden kÃ¶nnen.</p>
<figure>
<embed src="img/02_eulerangle/eulerangle.pdf" /><figcaption>Darstellung der Tait-Bryan-Winkel nach z-y-x (intrinsisch) Konvention </figcaption>
</figure>
<p>Die am hÃ¤ufigsten verwendete Konvention ist die <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-Konvention (intrinsische Konvention), wobei <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> die Reihenfolge der zu drehenden Achsen definiert. Intrinsisch bedeutet, dass jeweils um die neu entstehende Achse gedreht wird. Abbildung  zeigt schrittweise wie mit dieser Konvention Koordinatensysteme gedreht werden. Im Gegensatz zu intrinsischen Drehungen werden extrinsische Drehungen um die Achse des alten Koordinatensystems gedreht. Jede intrinsische Drehung kann in eine extrinsische Drehung umgewandelt werden und vice versa. Die Drehung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> ist beispielsweise intrinsisch Ã¤quivalent mit der extrinsischen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-Drehung.</p>
<h3 id="drehmatrix">Drehmatrix</h3>
<p>Eine andere MÃ¶glichkeit, die Euler-Winkel zu manipulieren, ist die Drehmatrix. Sie ergibt sich aus der Multiplikation dreier Matrizen, die eine Rotation um die jeweilige Koordinaten-Achse beschreiben: <span id="eq:Drehmatrix" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>âˆ’</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">âŸ</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>ğ‘</mi><mi>ğ³</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder><mo>â‹…</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mo>âˆ’</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">âŸ</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>ğ‘</mi><mi>ğ²</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder><mo>â‹…</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>âˆ’</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">âŸ</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>ğ‘</mi><mi>ğ±</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder></mrow><annotation encoding="application/x-tex">
    \mathbf{R}(\vec{\varphi}) =
    \underbrace{ 
        \begin{bmatrix}
            \cos(\varphi_z) &amp; -\sin(\varphi_z) &amp; 0 \\
            \sin(\varphi_z) &amp;  \cos(\varphi_z) &amp; 0 \\
            0            &amp; 0             &amp; 1 \\
        \end{bmatrix}
    }_{\mathbf{R_z}(\varphi_z)} \cdot
    \underbrace{   
        \begin{bmatrix}
            \cos(\varphi_y) &amp; 0 &amp; \sin(\varphi_y)   \\
            0            &amp; 1 &amp; 0              \\
        -\sin(\varphi_y) &amp; 0 &amp; \cos(\varphi_y)   \\
        \end{bmatrix}
    }_{\mathbf{R_y}(\varphi_y)} \cdot
    \underbrace{ 
        \begin{bmatrix}
            1 &amp;  0            &amp; 0              \\
            0 &amp;  \cos(\varphi_x) &amp; -\sin(\varphi_x)  \\
            0 &amp;  \sin(\varphi_x) &amp; \cos(\varphi_x)   
        \end{bmatrix}
    }_{\mathbf{R_x}(\varphi_x)}
</annotation></semantics></math><span class="eqnos-number">(2)</span></span>  Um einen Vektor vom Inertialsystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>â„•</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> in das KÃ¶rpersystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> (Rotation des Punktes) zu transformieren, wird der zu rotierende Vektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mstyle mathvariant="double-struck"><mi>â„•</mi></mstyle></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mi>x</mi></msub><mo>,</mo><msub><mi>v</mi><mi>y</mi></msub><mo>,</mo><msub><mi>v</mi><mi>z</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{v}_{\mathbb{N}} = (v_x, v_y, v_z)^T</annotation></semantics></math> mit der Drehmatrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{R}(\vec{\varphi})</annotation></semantics></math> multipliziert: <span id="eq:Drehmatrix_rot1" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle></msub><mo>=</mo><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>â‹…</mo><msub><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mstyle mathvariant="double-struck"><mi>â„•</mi></mstyle></msub></mrow><annotation encoding="application/x-tex">
    \vec{v}_{\mathbb{B}} = \mathbf{R}(\vec{\varphi}) \cdot \vec{v}_{\mathbb{N}}
</annotation></semantics></math><span class="eqnos-number">(3)</span></span>  Die Indizes geben dabei das Koordinatensystem des jeweiligen Vektors an. Soll ein Vektor vom KÃ¶rpersystem in das Inertialsystem (Rotation des Koordinatensystems) transformiert werden, muss der zu rotierende Vektor mit der inversen Drehmatrix multipliziert werden: <span id="eq:Drehmatrix_rot2" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>â‹…</mo><msub><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mstyle mathvariant="double-struck"><mi>â„•</mi></mstyle></msub></mrow><annotation encoding="application/x-tex">
    \vec{v}_{\mathbb{B}} = \left(\mathbf{R}(\vec{\varphi})\right)^{-1} \cdot \vec{v}_{\mathbb{N}}
</annotation></semantics></math><span class="eqnos-number">(4)</span></span> </p>
<h2 id="bestimmung-der-abgeleiteten-grÃ¶ÃŸen">Bestimmung der abgeleiteten GrÃ¶ÃŸen</h2>
<p>Um die Geschwindigkeit oder die Beschleunigung zu bestimmen muss der Weg durch Differenzieren nach der Zeit bestimmt werden:</p>
<p><span id="eq:geschwindigkeit" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{v}(t) = \frac{\mathrm{d}\vec{s}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(5)</span></span> </p>
<p><span id="eq:beschleunigung" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{a}(t) = \frac{\mathrm{d}\vec{v}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(6)</span></span> </p>
<p>Die Winkelgeschwindigkeit wird nicht Ã¼ber die Euler-Winkel, sondern Ã¼ber die Rotationsmatrix bestimmt:</p>
<p><span id="eq:winkelgeschwindigkeit" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>âˆ’</mo><msub><mi>Ï‰</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><msub><mi>Ï‰</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>Ï‰</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>âˆ’</mo><msub><mi>Ï‰</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mo>âˆ’</mo><msub><mi>Ï‰</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><msub><mi>Ï‰</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mstyle mathvariant="bold"><mi>ğ›€</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac><mstyle mathvariant="bold"><mi>ğ‘</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
     0           &amp; -\omega_z(t) &amp;  \omega_y(t) \\
     \omega_z(t) &amp; 0            &amp; -\omega_x(t) \\
    -\omega_y(t) &amp; \omega_x(t)  &amp;  0           \\
\end{bmatrix} = 
\mathbf{\Omega}(t) = \frac{\mathrm{d} \mathbf{R}(t)}{\mathrm{d} t} \mathbf{R}(t)^{-1}
</annotation></semantics></math><span class="eqnos-number">(7)</span></span> </p>
<p>AnschlieÃŸend kann die Winkelbeschleunigung mit anschlieÃŸendem differenzieren gewonnen werden:</p>
<p><span id="eq:winkelbeschleunigung" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\vec{\alpha}(t) = \frac{\mathrm{d}\vec{\omega}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(8)</span></span> </p>
<p>Mit Matlab kann die Differentiation sowohl symbolisch (mit der Symbolic Math Toolbox) als auch nummerisch (mit der Funktion <code>x_ = gradient(x,t)</code>) durchgefÃ¼hrt werden</p>
<h2 id="mechanische-grundlagen">Mechanische Grundlagen</h2>
<p>Um die Daten der IMU (am Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>) anhand der GrÃ¶ÃŸen am Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> zu bestimmen, kann folgende kinematische Beziehung angewandt werden: <span id="eq:kinematisch" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><msub><mi>a</mi><mi>I</mi></msub><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mover><msub><mi>a</mi><mi>S</mi></msub><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mover><mi>r</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mover><mi>r</mi><mo accent="true">âƒ—</mo></mover></mrow><annotation encoding="application/x-tex">
    \vec{a_I}(t) = \vec{a_S}(t) + \vec{\omega}(t) \times \left( \vec{\omega}(t) \times \vec{r} \right) + \vec{\alpha}(t) \times \vec{r}
</annotation></semantics></math><span class="eqnos-number">(9)</span></span>  Die einzelnen GrÃ¶ÃŸen kÃ¶nnen folgendermaÃŸen interpretiert werden:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mi>S</mi></msub><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{a_S}</annotation></semantics></math> ist die Beschleunigung im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> und setzt sich aus Gravitationsbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>g</mi><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{g}</annotation></semantics></math> und linearer Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mstyle mathvariant="normal"><mi>l</mi></mstyle></msub><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{a_\mathrm{l}}</annotation></semantics></math> zusammen.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mover><mi>r</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{\omega}(t) \times \left( \vec{\omega}(t) \times \vec{r} \right)</annotation></semantics></math> entspricht der Zentrifugalbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mstyle mathvariant="normal"><mi>c</mi></mstyle></msub><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{a_\mathrm{c}}</annotation></semantics></math>, die durch die Drehung des starren KÃ¶rpers entsteht.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mover><mi>r</mi><mo accent="true">âƒ—</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t) \times \vec{r}</annotation></semantics></math> entspricht der Euler-Kraft und entsteht durch eine beschleunigte Drehung des starren KÃ¶rpers mit der Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t)</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mi>I</mi></msub><mo accent="true">âƒ—</mo></mover><annotation encoding="application/x-tex">\vec{a_I}</annotation></semantics></math> ist die resultierende Beschleunigung an der Punkt der IMU.</li>
</ul>
<h2 id="tangentialvektor-tangentialwinkel">Tangentialvektor / Tangentialwinkel</h2>
<p>In den meisten FÃ¤llen ist es Ã¼blich, dass bewegte Fahrzeuge (Autos, Flugzeuge) tangential zur Trajektorie ausgerichtet sind (bei Drohen ist das nicht der Fall). Der Tangentialvektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{t}(t) = (t_x(t), t_y(t), t_z(t))^T</annotation></semantics></math> kann Ã¼ber die lineare Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{v}(t)</annotation></semantics></math> bestimmt werden:</p>
<p><span id="eq:tang" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">|</mo><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{t}(t) = \frac{\vec{v}(t)}{|\vec{v}(t)|}
</annotation></semantics></math><span class="eqnos-number">(10)</span></span></p>
<p>Anhand dieses Vektors kÃ¶nnen die Euler-Winkel bestimmt werden die eine Rotation zwischen dem Inertialsystem und dem Tangentialvektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{t}(t)</annotation></semantics></math> beschreibt. Da es sich aber nur um einen Vektor handel kÃ¶nnen nur zwei der drei Euler-Winkel (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\varphi_z</annotation></semantics></math> und <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\varphi_y</annotation></semantics></math>) gefunden werden, der dritte Euler-Winkel (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï†</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\varphi_x</annotation></semantics></math>) wird <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> gesetzt:</p>
<p><span id="eq:tang_z" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï†</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mstyle mathvariant="normal"><mi>a</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
    \varphi_z(t) = \mathrm{atan2}(t_y(t), t_x(t))
</annotation></semantics></math><span class="eqnos-number">(11)</span></span></p>
<p><span id="eq:tang_y" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï†</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo>âˆ’</mo><mstyle mathvariant="normal"><mi>a</mi><mi>s</mi><mi>i</mi><mi>n</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">|</mo><mover><mi>t</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
    \varphi_y(t) = -\mathrm{asin} \left( \frac{t_z(t)}{|\vec{t}(t)|} \right)
</annotation></semantics></math><span class="eqnos-number">(12)</span></span></p>
<p><span id="eq:tang_x" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï†</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
    \varphi_x(t) = 0
</annotation></semantics></math><span class="eqnos-number">(13)</span></span></p>

<h1 id="funktionen">Funktionen</h1>
<p>Im Nachfolgendem werden die einzelnen Funktionen beschrieben, um Daten einer IMU zu bestimmen und darzustellen.</p>
<h2 id="lineare-grÃ¶ÃŸen-my_lin">Lineare GrÃ¶ÃŸen <code>my_lin</code></h2>
<p>Mit der Funktion <code>my_lin</code> werden die lineare Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{v}(t)</annotation></semantics></math> und lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{a}(t)</annotation></semantics></math> anhand der Trajektorie <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>s</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{s}(t)</annotation></semantics></math> bestimmt. Dazu werden (<a href="#eq:geschwindigkeit">5</a>) und (<a href="#eq:beschleunigung">6</a>) angewandt.</p>
<h3 id="syntax">Syntax</h3>
<p><code>[s_calc, v_calc, a_calc] = my_lin(s, option, t_)</code></p>
<h3 id="parameter">Parameter</h3>
<ul>
<li><code>s</code> 3D-Vektor oder Cell mit 3 Vektorfunktionen der Trajektorie</li>
<li><code>option</code> String: <code>'num'</code> oder <code>'sym'</code> zur Auswahl fÃ¼r nummerische oder symbolische Berechnung</li>
<li><code>t_</code> 1D-Zeitvektor</li>
<li><code>s_calc</code> berechneter 3D-Vektor fÃ¼r die Trajektorie (im nummerischen fall ident mit <code>s</code>)</li>
<li><code>v_calc</code> berechneter 3D-Vektor fÃ¼r die lineare Geschwindigkeit</li>
<li><code>a_calc</code> berechneter 3D-Vektor fÃ¼r die lineare Beschleunigung</li>
</ul>
<h3 id="beispiel">Beispiel</h3>
<h4 id="nummerisch">Nummerisch</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb4-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb4-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb4-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb4-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co">%% Berechnung lineare GrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb4-19" title="19">[s, v, a] = my_lin(s,&quot;num&quot;,t);</a></code></pre></div>
<h4 id="symbolisch">Symbolisch</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb5-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb5-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb5-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb5-12" title="12">sx = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-13" title="13">sy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-14" title="14">sz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16">s = {sx, sy, sz};</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">%% Berechnung lineare GrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb5-19" title="19">[s, v, a] = my_lin(s,&quot;sym&quot;,t);</a></code></pre></div>
<h2 id="tangentialwinkel-my_tang">Tangentialwinkel <code>my_tang</code></h2>
<p>Mit der Funktion <code>my_tang</code> kÃ¶nnen die Euler-Winkel bestimmt werden, die benÃ¶tigt werden um einen Vektor vom Inertialsystem in ein KÃ¶rperkoordinatensystem (ausgerichtet zum Tangentialvektor) zu drehen. Dazu werden (<a href="#eq:tang">10</a>) - (<a href="#eq:tang_x">13</a>) angewandt.</p>
<h3 id="syntax-1">Syntax</h3>
<p><code>[phi_tz, phi_ty, phi_tx, ta] = my_tang(v, t)</code></p>
<h3 id="parameter-1">Parameter</h3>
<ul>
<li><code>v</code> 3D-Vektor der linearen Geschwindigkeit</li>
<li><code>t</code> Zeit</li>
<li><code>phi_tz</code> 1D-Vektor fÃ¼r z-Komponente der Euler-Winkel</li>
<li><code>phi_ty</code> 1D-Vektor fÃ¼r y-Komponente der Euler-Winkel</li>
<li><code>phi_tx</code> 1D-Vektor fÃ¼r x-Komponente der Euler-Winkel</li>
<li><code>ta</code> 3D-Vektor fÃ¼r Tangentialvektor</li>
</ul>
<h3 id="beispiel-1">Beispiel</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb6-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb6-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb6-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb6-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-15" title="15"></a>
<a class="sourceLine" id="cb6-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="co">%% Berechnung lineare GrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb6-19" title="19">[s, v, a] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb6-22" title="22">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v, t);</a></code></pre></div>
<h2 id="winkel-grÃ¶ÃŸen-my_ang">Winkel GrÃ¶ÃŸen <code>my_ang</code></h2>
<p>Mit der Funktion <code>my_ang</code> werden die Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï‰</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\omega}(t)</annotation></semantics></math> und Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î±</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t)</annotation></semantics></math> anhand der Euler-Winkel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Ï†</mi><mo accent="true">âƒ—</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\varphi}(t)</annotation></semantics></math> bestimmt. Dazu werden (<a href="#eq:winkelgeschwindigkeit">7</a>) und (<a href="#eq:winkelbeschleunigung">8</a>) angewandt.</p>
<h3 id="syntax-2">Syntax</h3>
<p><code>[phi_calc, omega_calc, alpha_calc] = my_ang(phi, option, t_)</code></p>
<h3 id="parameter-2">Parameter</h3>
<ul>
<li><code>phi</code> 3D-Vektor oder Cell mit 3 Vektorfunktionen der Eulerwinkel</li>
<li><code>option</code> String: <code>'num'</code> oder <code>'sym'</code> zur Auswahl fÃ¼r nummerische oder symbolische Berechnung</li>
<li><code>t_</code> 1D-Zeitvektor</li>
<li><code>phi_calc</code> berechneter 3D-Vektor fÃ¼r die Euler-Winkel (im nummerischen fall ident mit <code>s</code>)</li>
<li><code>omega_calc</code> berechneter 3D-Vektor fÃ¼r die Winkelgeschwindigkeit</li>
<li><code>alpha_calc</code> berechneter 3D-Vektor fÃ¼r die Winkelbeschleunigung</li>
</ul>
<h3 id="beispiel-2">Beispiel</h3>
<h4 id="nummerisch-1">Nummerisch</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb7-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb7-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb7-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb7-12" title="12">phix = <span class="fl">0</span> .* t; <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-13" title="13">phiy = <span class="fl">0</span> .* t; <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-14" title="14">phiz = <span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16">phi = [phix&#39;, phiy&#39;, phiz&#39;];</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="co">%% Berechnung WinkelgrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb7-19" title="19">[phi, omega, alpha] = my_ang(phi,&quot;num&quot;,t);</a></code></pre></div>
<h4 id="symbolisch-1">Symbolisch</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb8-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb8-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb8-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb8-12" title="12">phix = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-13" title="13">phiy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-14" title="14">phiz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">phi = {phix, phiy, phiz};</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="co">%% Berechnung WinkelgrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb8-19" title="19">[phi, omega, alpha] = my_ang(phi,&quot;sym&quot;,t);</a></code></pre></div>
<h2 id="rotation-my_rotate">Rotation <code>my_rotate</code></h2>
<p>Mit der Funktion <code>my_rotate</code> kÃ¶nnen Punkte oder Vektoren von einem Koordinatensystem (z.B. das Inertialsystem) in ein anderes Koordinatensystem (z.B. das KÃ¶rperkoordinatensystem gedreht werden). Dazu wird (<a href="#eq:Drehmatrix">2</a>) und (<a href="#eq:Drehmatrix_rot1">3</a>) verwendet.</p>
<h3 id="syntax-3">Syntax</h3>
<p><code>[aB] = my_rotate(phi, aN, t)</code></p>
<h3 id="parameter-3">Parameter</h3>
<ul>
<li><code>phi</code> 3D-Vektor der Euler-Winkel (Orientierung zwischen Inertialsystem und KÃ¶rperkoordinatensystem)</li>
<li><code>aN</code> 3D-Vektor im Inertialsystem</li>
<li><code>t</code> Zeit</li>
<li><code>aB</code> 3D-Vektor im KÃ¶rperkoordinatensystem</li>
<li><code>phi_tx</code> 1D-Vektor fÃ¼r x-Komponente der Euler-Winkel</li>
</ul>
<h3 id="beispiel-3">Beispiel</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb9-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb9-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb9-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb9-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb9-17" title="17"></a>
<a class="sourceLine" id="cb9-18" title="18"><span class="co">%% Berechnung lineare GrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb9-19" title="19">[s_N, v_N, a_N] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb9-20" title="20"><span class="co">% lineare GrÃ¶ÃŸen im Schwerpunkt S und referenzerit auf das Inertialsystem N</span></a>
<a class="sourceLine" id="cb9-21" title="21"></a>
<a class="sourceLine" id="cb9-22" title="22"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb9-23" title="23">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v_N, t);</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25">phi = [phi_tx, phi_ty, phi_tz];</a>
<a class="sourceLine" id="cb9-26" title="26"></a>
<a class="sourceLine" id="cb9-27" title="27"><span class="co">%% Rotation der lineare Beschleunigung</span></a>
<a class="sourceLine" id="cb9-28" title="28">[a_B] = my_rotate(phi, a_N, t); </a>
<a class="sourceLine" id="cb9-29" title="29"><span class="co">% lineare Beschleunigung im Schwerpunkt S und referenzerit auf das KÃ¶rperkoorinatensystem B</span></a></code></pre></div>
<h2 id="imu-grÃ¶ÃŸen-my_imu">IMU GrÃ¶ÃŸen <code>my_imu</code></h2>
<p>Mit der Funktion <code>my_imu</code> kÃ¶nnen anhand der GrÃ¶ÃŸen im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> die Winkelgeschwindigkeit und die lineare Beschleunigung im Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> bestimmt werden. Dazu kann (<a href="#eq:kinematisch">9</a>) verwendet werden. Damit die Daten aus der Sicht der IMU bestimmt werden mÃ¼ssen GrÃ¶ÃŸen im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> ins KÃ¶rperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> gedreht werden. Dazu kann die Funktion <code>my_rot</code> verwendet werden.</p>
<h3 id="syntax-4">Syntax</h3>
<p><code>[aIMU] = my_imu(aB, omega, alpha, r, t)</code></p>
<h3 id="parameter-4">Parameter</h3>
<ul>
<li><code>aS</code> 3D-Vektor der linearen Beschleunigung im KÃ¶rperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> am Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math></li>
<li><code>omega</code> 3D-Vektor der Winkelgeschwindigkeit</li>
<li><code>alpha</code> 3D-Vektor der Winkelbeschleunigung</li>
<li><code>r</code> Abstandsvektor zwischen Schwerpunkt und IMU</li>
<li><code>t</code> 1D-Vektor der Zeit</li>
<li><code>aIMU</code> 3D-Vektor der linearen Beschleunigung im KÃ¶rperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ğ”¹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> am Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math></li>
</ul>
<h3 id="beispiel-4">Beispiel</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb10-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb10-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb10-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb10-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb10-17" title="17"></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="co">%% Position IMU</span></a>
<a class="sourceLine" id="cb10-19" title="19">r = [-<span class="fl">150e-3</span>,-<span class="fl">150e-3</span>,<span class="fl">50e-3</span>]./<span class="fl">2</span>; <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-20" title="20"></a>
<a class="sourceLine" id="cb10-21" title="21"><span class="co">%% Berechnung lineare GrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb10-22" title="22">[s_S_N, v_S_N, a_S_N] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb10-23" title="23"><span class="co">% lineare GrÃ¶ÃŸen im Schwerpunkt S und referenzerit auf das Inertialsystem N</span></a>
<a class="sourceLine" id="cb10-24" title="24"></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb10-26" title="26">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v_S_N, t);</a>
<a class="sourceLine" id="cb10-27" title="27"></a>
<a class="sourceLine" id="cb10-28" title="28">phi = [phi_tx, phi_ty, phi_tz];</a>
<a class="sourceLine" id="cb10-29" title="29"></a>
<a class="sourceLine" id="cb10-30" title="30"><span class="co">%% Berechnung WineklgrÃ¶ÃŸen</span></a>
<a class="sourceLine" id="cb10-31" title="31">[phi, omega, alpha] = my_ang(phi,&quot;num&quot;,t); </a>
<a class="sourceLine" id="cb10-32" title="32"><span class="co">% WinkelgrÃ¶ÃŸen des starren KÃ¶rpers (sind am gesammten KÃ¶rper ident)</span></a>
<a class="sourceLine" id="cb10-33" title="33"></a>
<a class="sourceLine" id="cb10-34" title="34"><span class="co">%% Rotation der lineare Beschleunigung</span></a>
<a class="sourceLine" id="cb10-35" title="35">[a_S_B] = my_rotate(phi, a_S_N, t); </a>
<a class="sourceLine" id="cb10-36" title="36"><span class="co">% lineare Beschleunigung im Schwerpunkt S und referenzerit auf das KÃ¶rperkoorinatensystem B</span></a>
<a class="sourceLine" id="cb10-37" title="37"></a>
<a class="sourceLine" id="cb10-38" title="38"><span class="co">%% Berechnung IMU Daten</span></a>
<a class="sourceLine" id="cb10-39" title="39">[a_I_B] = my_imu(a_S_B, omega, alpha, r, t);</a>
<a class="sourceLine" id="cb10-40" title="40"></a>
<a class="sourceLine" id="cb10-41" title="41"><span class="co">% a_I_B entspricht gemessenen Beschleunigung der IMU</span></a>
<a class="sourceLine" id="cb10-42" title="42">a_IMU = a_I_B;</a>
<a class="sourceLine" id="cb10-43" title="43"><span class="co">% omega entspricht der gemessenen Winkelgeschwindigkeit der IMU</span></a>
<a class="sourceLine" id="cb10-44" title="44">omega_IMU = omega; </a></code></pre></div>

<h1 id="beispiele">Beispiele</h1>
</body>
</html>
