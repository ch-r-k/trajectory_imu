<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christoph Kurz" />
  <title>IMU-Daten einer Trajektorie</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f4f4f4; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #006400; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">IMU-Daten einer Trajektorie</h1>
<p class="author">Christoph Kurz</p>
</header>

<p>[[TOC]]</p>
<h1 id="anwendung">Anwendung</h1>
<p>Im Folgenden soll ein Matlab-Tool vorgestellt werden, das es ermöglicht, anhand einer vorgegebenen Trajektorie und einer vorgegebenen Orientierung die Ausgangsdaten einer IMU (Inertialen Messeinheit) zu simulieren. Die Vorgabe der Trajektorie <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>s</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{s}(t)</annotation></semantics></math> und der Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\varphi}(t)</annotation></semantics></math> soll mithilfe einer Funktion (zur symbolischen Berechnung) und mithilfe eines Vektors (zur nummerischen Berechnung) möglich sein:</p>
<p>Vorgabe mithilfe von Funktionen:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb1-1" title="1"><span class="co">% Trajektorie als Funktion</span></a>
<a class="sourceLine" id="cb1-2" title="2">sx = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-3" title="3">sy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-4" title="4">sz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*<span class="fl">3</span>*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">% Orientierung als Funktion</span></a>
<a class="sourceLine" id="cb1-7" title="7">phix = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb1-8" title="8">phiy = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb1-9" title="9">phiz = @(t) (<span class="fl">0</span> .* t); <span class="co">% rad</span></a></code></pre></div>
<p>Vorgabe mithilfe von Vektoren:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb2-1" title="1"><span class="co">% Zeit Vektor</span></a>
<a class="sourceLine" id="cb2-2" title="2">t = (<span class="fl">0</span> : <span class="fl">0.01</span> : <span class="fl">5</span>); <span class="co">% s</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">% Trajektorie als Vektor</span></a>
<a class="sourceLine" id="cb2-5" title="5">sx = (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-6" title="6">sy = (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-7" title="7">sz = (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*<span class="fl">3</span>*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">% Orientierung als Vektor</span></a>
<a class="sourceLine" id="cb2-10" title="10">phix = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb2-11" title="11">phiy = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb2-12" title="12">phiz = (<span class="fl">0</span> .* t); <span class="co">% rad</span></a></code></pre></div>
<p>Entlang dieser Vorgegebenen Trajektorie bewegt sich der Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> eines starren Körpers. Die Inertiale Messeinheit ist dabei im Abstand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>r</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math> vom Schwerpunkt entfernt.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb3-1" title="1">r = [-<span class="fl">75e-3</span>, -<span class="fl">75e-3</span>, <span class="fl">25e-3</span>]; <span class="co">% m</span></a></code></pre></div>
<p>Um dies zu Verdeutlichen wird in der Abbildung  die oben definierte Trajektorie abgebildet.</p>
<figure>
<embed src="img/01_trajectory/trajectory.pdf" /><figcaption>Beispiel einer Trajektorie mit einer IMU </figcaption>
</figure>
<p>Hierbei wird der starre Körper als rotes Dreieck dargestellt das sich entlang der Trajektorie fortbewegt. Die Orientierung des starren Körpers wurde so gewählt, dass er sich entlang des Tangentialvektors der Trajektorie ausrichtet. Der Schwerpunkt und die Position der IMU werden mit einem gelben und violetten Punkt markiert.</p>

<h1 id="grundlagen">Grundlagen</h1>
<p>Bevor näher auf die Algorithmen eingegangen wird, werdend die Grundlagen beschrieben, die im Weiteren von Bedeutung sind. Hierbei sind der Weg <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math> und die Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math> von Bedeutung. Daraus ergeben sich 6 Freiheitsgrade, damit Position und Lage eines Körpers im Raum beschrieben werden kann. Weiters sind die folgenden Ableitungen dieser Größen von Bedeutung:</p>
<ul>
<li>die Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mover><mover><mi>s</mi><mo accent="true">⃗</mo></mover><mo accent="true">̇</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v} = \dot{\vec{s}}</annotation></semantics></math></li>
<li>die Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mover><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo accent="true">̇</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\omega} = \dot{\vec{\varphi}}</annotation></semantics></math></li>
<li>die lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mover><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo accent="true">̇</mo></mover></mrow><annotation encoding="application/x-tex">\vec{a} = \dot{\vec{v}}</annotation></semantics></math></li>
<li>die Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mover><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo accent="true">̇</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\alpha} = \dot{\vec{\omega}}</annotation></semantics></math></li>
</ul>
<p>Wobei <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mrow><mo stretchy="false" form="prefix">(</mo><mo>⋅</mo><mo stretchy="false" form="postfix">)</mo></mrow><mo accent="true">̇</mo></mover><annotation encoding="application/x-tex">\dot{(\cdot)}</annotation></semantics></math> die zeitliche Ableitung kennzeichnet. Die beschriebenen Größen lassen sich in lineare Größen (Weg <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>, Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>v</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math>, lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>a</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{a}</annotation></semantics></math>) und in Drehgrößen (Orientierung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math>, Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{\omega}</annotation></semantics></math>, Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>α</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{\alpha}</annotation></semantics></math>) unterteilen.</p>
<h2 id="orientierung-im-dreidimensionalen-raum-mithilfe-von-euler-winkeln-und-drehmatrizen">Orientierung im dreidimensionalen Raum mithilfe von Euler-Winkeln und Drehmatrizen</h2>
<p>Um die Orientierung von Körpern zu beschreiben werden Euler-Winkel verwendet. Aus diesen können Drehmatrizen gewonnen werden, die eine Rotation des Koordinatensystem (eine Änderung der Orientierung) ermöglichen. Dazu müssen verschiedenen Koordinatensysteme eingeführt werden:</p>
<ul>
<li>Inertialsystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></li>
<li>Körperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math></li>
</ul>
<p>Das Inertialsystem wird nach ENU-Konvention definiert. ENU bedeutet East, North, Up (also Osten, Norden, oben) und beschreibt die Richtung der Koordinaten-Achsen (Osten <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">= x</annotation></semantics></math>, Norden <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">= y</annotation></semantics></math> und oben <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">= z</annotation></semantics></math>). Die Körperkoordinatensysteme beschreibt das Koordinatensystem des starren Körpers.</p>
<h3 id="euler-winkel">Euler-Winkel</h3>
<p>Die Euler-Winkel beschreiben die Drehlage/Orientierung eines Körpers durch 3 Winkel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\varphi_x</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\varphi_y</annotation></semantics></math> und <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\varphi_z</annotation></semantics></math> der jeweiligen Achse. Zusammen beschreiben sie den Vektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{\varphi}</annotation></semantics></math>: <span id="eq:euler_winkel" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>φ</mi><mi>x</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>φ</mi><mi>y</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>φ</mi><mi>z</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
    \vec{\varphi} = 
    \begin{bmatrix}
        \varphi_x \\
        \varphi_y \\
        \varphi_z \\
    \end{bmatrix}
</annotation></semantics></math><span class="eqnos-number">(1)</span></span>  Es wird unterschieden zwischen den klassischen Euler-Winkeln und den Tait-Bryan-Winkeln, wobei diese wieder in unterschiedliche Konventionen eingeteilt werden können.</p>
<figure>
<embed src="img/02_eulerangle/eulerangle.pdf" /><figcaption>Darstellung der Tait-Bryan-Winkel nach z-y-x (intrinsisch) Konvention </figcaption>
</figure>
<p>Die am häufigsten verwendete Konvention ist die <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-Konvention (intrinsische Konvention), wobei <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> die Reihenfolge der zu drehenden Achsen definiert. Intrinsisch bedeutet, dass jeweils um die neu entstehende Achse gedreht wird. Abbildung  zeigt schrittweise wie mit dieser Konvention Koordinatensysteme gedreht werden. Im Gegensatz zu intrinsischen Drehungen werden extrinsische Drehungen um die Achse des alten Koordinatensystems gedreht. Jede intrinsische Drehung kann in eine extrinsische Drehung umgewandelt werden und vice versa. Die Drehung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> ist beispielsweise intrinsisch äquivalent mit der extrinsischen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>-Drehung.</p>
<h3 id="drehmatrix">Drehmatrix</h3>
<p>Eine andere Möglichkeit, die Euler-Winkel zu manipulieren, ist die Drehmatrix. Sie ergibt sich aus der Multiplikation dreier Matrizen, die eine Rotation um die jeweilige Koordinaten-Achse beschreiben: <span id="eq:Drehmatrix" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>−</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">⏟</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>𝐑</mi><mi>𝐳</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder><mo>⋅</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mo>−</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">⏟</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>𝐑</mi><mi>𝐲</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder><mo>⋅</mo><munder><munder><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>−</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="true">⏟</mo></munder><mrow><mstyle mathvariant="bold"><msub><mi>𝐑</mi><mi>𝐱</mi></msub></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></munder></mrow><annotation encoding="application/x-tex">
    \mathbf{R}(\vec{\varphi}) =
    \underbrace{ 
        \begin{bmatrix}
            \cos(\varphi_z) &amp; -\sin(\varphi_z) &amp; 0 \\
            \sin(\varphi_z) &amp;  \cos(\varphi_z) &amp; 0 \\
            0            &amp; 0             &amp; 1 \\
        \end{bmatrix}
    }_{\mathbf{R_z}(\varphi_z)} \cdot
    \underbrace{   
        \begin{bmatrix}
            \cos(\varphi_y) &amp; 0 &amp; \sin(\varphi_y)   \\
            0            &amp; 1 &amp; 0              \\
        -\sin(\varphi_y) &amp; 0 &amp; \cos(\varphi_y)   \\
        \end{bmatrix}
    }_{\mathbf{R_y}(\varphi_y)} \cdot
    \underbrace{ 
        \begin{bmatrix}
            1 &amp;  0            &amp; 0              \\
            0 &amp;  \cos(\varphi_x) &amp; -\sin(\varphi_x)  \\
            0 &amp;  \sin(\varphi_x) &amp; \cos(\varphi_x)   
        \end{bmatrix}
    }_{\mathbf{R_x}(\varphi_x)}
</annotation></semantics></math><span class="eqnos-number">(2)</span></span>  Um einen Vektor vom Inertialsystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> in das Körpersystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> (Rotation des Punktes) zu transformieren, wird der zu rotierende Vektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mi>x</mi></msub><mo>,</mo><msub><mi>v</mi><mi>y</mi></msub><mo>,</mo><msub><mi>v</mi><mi>z</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{v}_{\mathbb{N}} = (v_x, v_y, v_z)^T</annotation></semantics></math> mit der Drehmatrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{R}(\vec{\varphi})</annotation></semantics></math> multipliziert: <span id="eq:Drehmatrix_rot1" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle></msub><mo>=</mo><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></msub></mrow><annotation encoding="application/x-tex">
    \vec{v}_{\mathbb{B}} = \mathbf{R}(\vec{\varphi}) \cdot \vec{v}_{\mathbb{N}}
</annotation></semantics></math><span class="eqnos-number">(3)</span></span>  Die Indizes geben dabei das Koordinatensystem des jeweiligen Vektors an. Soll ein Vektor vom Körpersystem in das Inertialsystem (Rotation des Koordinatensystems) transformiert werden, muss der zu rotierende Vektor mit der inversen Drehmatrix multipliziert werden: <span id="eq:Drehmatrix_rot2" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></msub></mrow><annotation encoding="application/x-tex">
    \vec{v}_{\mathbb{B}} = \left(\mathbf{R}(\vec{\varphi})\right)^{-1} \cdot \vec{v}_{\mathbb{N}}
</annotation></semantics></math><span class="eqnos-number">(4)</span></span> </p>
<h2 id="bestimmung-der-abgeleiteten-größen">Bestimmung der abgeleiteten Größen</h2>
<p>Um die Geschwindigkeit oder die Beschleunigung zu bestimmen muss der Weg durch Differenzieren nach der Zeit bestimmt werden:</p>
<p><span id="eq:geschwindigkeit" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>s</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{v}(t) = \frac{\mathrm{d}\vec{s}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(5)</span></span> </p>
<p><span id="eq:beschleunigung" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{a}(t) = \frac{\mathrm{d}\vec{v}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(6)</span></span> </p>
<p>Die Winkelgeschwindigkeit wird nicht über die Euler-Winkel, sondern über die Rotationsmatrix bestimmt:</p>
<p><span id="eq:winkelgeschwindigkeit" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>−</mo><msub><mi>ω</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><msub><mi>ω</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>ω</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>−</mo><msub><mi>ω</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mo>−</mo><msub><mi>ω</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><msub><mi>ω</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mstyle mathvariant="bold"><mi>𝛀</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac><mstyle mathvariant="bold"><mi>𝐑</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>t</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
     0           &amp; -\omega_z(t) &amp;  \omega_y(t) \\
     \omega_z(t) &amp; 0            &amp; -\omega_x(t) \\
    -\omega_y(t) &amp; \omega_x(t)  &amp;  0           \\
\end{bmatrix} = 
\mathbf{\Omega}(t) = \frac{\mathrm{d} \mathbf{R}(t)}{\mathrm{d} t} \mathbf{R}(t)^{-1}
</annotation></semantics></math><span class="eqnos-number">(7)</span></span> </p>
<p>Anschließend kann die Winkelbeschleunigung mit anschließendem differenzieren gewonnen werden:</p>
<p><span id="eq:winkelbeschleunigung" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\vec{\alpha}(t) = \frac{\mathrm{d}\vec{\omega}(t)}{\mathrm{d} t}
</annotation></semantics></math><span class="eqnos-number">(8)</span></span> </p>
<p>Mit Matlab kann die Differentiation sowohl symbolisch (mit der Symbolic Math Toolbox) als auch nummerisch (mit der Funktion <code>x_ = gradient(x,t)</code>) durchgeführt werden</p>
<h2 id="mechanische-grundlagen">Mechanische Grundlagen</h2>
<p>Um die Daten der IMU (am Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>) anhand der Größen am Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> zu bestimmen, kann folgende kinematische Beziehung angewandt werden: <span id="eq:kinematisch" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><msub><mi>a</mi><mi>I</mi></msub><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mover><msub><mi>a</mi><mi>S</mi></msub><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mover><mi>r</mi><mo accent="true">⃗</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mover><mi>r</mi><mo accent="true">⃗</mo></mover></mrow><annotation encoding="application/x-tex">
    \vec{a_I}(t) = \vec{a_S}(t) + \vec{\omega}(t) \times \left( \vec{\omega}(t) \times \vec{r} \right) + \vec{\alpha}(t) \times \vec{r}
</annotation></semantics></math><span class="eqnos-number">(9)</span></span>  Die einzelnen Größen können folgendermaßen interpretiert werden:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mi>S</mi></msub><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{a_S}</annotation></semantics></math> ist die Beschleunigung im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> und setzt sich aus Gravitationsbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>g</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{g}</annotation></semantics></math> und linearer Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mstyle mathvariant="normal"><mi>l</mi></mstyle></msub><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{a_\mathrm{l}}</annotation></semantics></math> zusammen.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mover><mi>r</mi><mo accent="true">⃗</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{\omega}(t) \times \left( \vec{\omega}(t) \times \vec{r} \right)</annotation></semantics></math> entspricht der Zentrifugalbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mstyle mathvariant="normal"><mi>c</mi></mstyle></msub><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{a_\mathrm{c}}</annotation></semantics></math>, die durch die Drehung des starren Körpers entsteht.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mover><mi>r</mi><mo accent="true">⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t) \times \vec{r}</annotation></semantics></math> entspricht der Euler-Kraft und entsteht durch eine beschleunigte Drehung des starren Körpers mit der Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t)</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>a</mi><mi>I</mi></msub><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{a_I}</annotation></semantics></math> ist die resultierende Beschleunigung an der Punkt der IMU.</li>
</ul>
<h2 id="tangentialvektor-tangentialwinkel">Tangentialvektor / Tangentialwinkel</h2>
<p>In den meisten Fällen ist es üblich, dass bewegte Fahrzeuge (Autos, Flugzeuge) tangential zur Trajektorie ausgerichtet sind (bei Drohen ist das nicht der Fall). Der Tangentialvektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{t}(t) = (t_x(t), t_y(t), t_z(t))^T</annotation></semantics></math> kann über die lineare Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{v}(t)</annotation></semantics></math> bestimmt werden:</p>
<p><span id="eq:tang" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">|</mo><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \vec{t}(t) = \frac{\vec{v}(t)}{|\vec{v}(t)|}
</annotation></semantics></math><span class="eqnos-number">(10)</span></span></p>
<p>Anhand dieses Vektors können die Euler-Winkel bestimmt werden die eine Rotation zwischen dem Inertialsystem und dem Tangentialvektor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>t</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{t}(t)</annotation></semantics></math> beschreibt. Da es sich aber nur um einen Vektor handel können nur zwei der drei Euler-Winkel (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>z</mi></msub><annotation encoding="application/x-tex">\varphi_z</annotation></semantics></math> und <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\varphi_y</annotation></semantics></math>) gefunden werden, der dritte Euler-Winkel (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\varphi_x</annotation></semantics></math>) wird <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> gesetzt:</p>
<p><span id="eq:tang_z" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mstyle mathvariant="normal"><mi>a</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
    \varphi_z(t) = \mathrm{atan2}(t_y(t), t_x(t))
</annotation></semantics></math><span class="eqnos-number">(11)</span></span></p>
<p><span id="eq:tang_y" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo>−</mo><mstyle mathvariant="normal"><mi>a</mi><mi>s</mi><mi>i</mi><mi>n</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">|</mo><mover><mi>t</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
    \varphi_y(t) = -\mathrm{asin} \left( \frac{t_z(t)}{|\vec{t}(t)|} \right)
</annotation></semantics></math><span class="eqnos-number">(12)</span></span></p>
<p><span id="eq:tang_x" class="eqnos"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>x</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
    \varphi_x(t) = 0
</annotation></semantics></math><span class="eqnos-number">(13)</span></span></p>

<h1 id="funktionen">Funktionen</h1>
<p>Im Nachfolgendem werden die einzelnen Funktionen beschrieben, um Daten einer IMU zu bestimmen und darzustellen.</p>
<h2 id="lineare-größen-my_lin">Lineare Größen <code>my_lin</code></h2>
<p>Mit der Funktion <code>my_lin</code> werden die lineare Geschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{v}(t)</annotation></semantics></math> und lineare Beschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{a}(t)</annotation></semantics></math> anhand der Trajektorie <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>s</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{s}(t)</annotation></semantics></math> bestimmt. Dazu werden (<a href="#eq:geschwindigkeit">5</a>) und (<a href="#eq:beschleunigung">6</a>) angewandt.</p>
<h3 id="syntax">Syntax</h3>
<p><code>[s_calc, v_calc, a_calc] = my_lin(s, option, t_)</code></p>
<h3 id="parameter">Parameter</h3>
<ul>
<li><code>s</code> 3D-Vektor oder Cell mit 3 Vektorfunktionen der Trajektorie</li>
<li><code>option</code> String: <code>'num'</code> oder <code>'sym'</code> zur Auswahl für nummerische oder symbolische Berechnung</li>
<li><code>t_</code> 1D-Zeitvektor</li>
<li><code>s_calc</code> berechneter 3D-Vektor für die Trajektorie (im nummerischen fall ident mit <code>s</code>)</li>
<li><code>v_calc</code> berechneter 3D-Vektor für die lineare Geschwindigkeit</li>
<li><code>a_calc</code> berechneter 3D-Vektor für die lineare Beschleunigung</li>
</ul>
<h3 id="beispiel">Beispiel</h3>
<h4 id="nummerisch">Nummerisch</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb4-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb4-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb4-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb4-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co">%% Berechnung lineare Größen</span></a>
<a class="sourceLine" id="cb4-19" title="19">[s, v, a] = my_lin(s,&quot;num&quot;,t);</a></code></pre></div>
<h4 id="symbolisch">Symbolisch</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb5-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb5-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb5-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb5-12" title="12">sx = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-13" title="13">sy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-14" title="14">sz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16">s = {sx, sy, sz};</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">%% Berechnung lineare Größen</span></a>
<a class="sourceLine" id="cb5-19" title="19">[s, v, a] = my_lin(s,&quot;sym&quot;,t);</a></code></pre></div>
<h2 id="tangentialwinkel-my_tang">Tangentialwinkel <code>my_tang</code></h2>
<p>Mit der Funktion <code>my_tang</code> können die Euler-Winkel bestimmt werden, die benötigt werden um einen Vektor vom Inertialsystem in ein Körperkoordinatensystem (ausgerichtet zum Tangentialvektor) zu drehen. Dazu werden (<a href="#eq:tang">10</a>) - (<a href="#eq:tang_x">13</a>) angewandt.</p>
<h3 id="syntax-1">Syntax</h3>
<p><code>[phi_tz, phi_ty, phi_tx, ta] = my_tang(v, t)</code></p>
<h3 id="parameter-1">Parameter</h3>
<ul>
<li><code>v</code> 3D-Vektor der linearen Geschwindigkeit</li>
<li><code>t</code> Zeit</li>
<li><code>phi_tz</code> 1D-Vektor für z-Komponente der Euler-Winkel</li>
<li><code>phi_ty</code> 1D-Vektor für y-Komponente der Euler-Winkel</li>
<li><code>phi_tx</code> 1D-Vektor für x-Komponente der Euler-Winkel</li>
<li><code>ta</code> 3D-Vektor für Tangentialvektor</li>
</ul>
<h3 id="beispiel-1">Beispiel</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb6-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb6-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb6-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb6-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb6-15" title="15"></a>
<a class="sourceLine" id="cb6-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="co">%% Berechnung lineare Größen</span></a>
<a class="sourceLine" id="cb6-19" title="19">[s, v, a] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb6-22" title="22">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v, t);</a></code></pre></div>
<h2 id="winkel-größen-my_ang">Winkel Größen <code>my_ang</code></h2>
<p>Mit der Funktion <code>my_ang</code> werden die Winkelgeschwindigkeit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>ω</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\omega}(t)</annotation></semantics></math> und Winkelbeschleunigung <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>α</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\alpha}(t)</annotation></semantics></math> anhand der Euler-Winkel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>φ</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec{\varphi}(t)</annotation></semantics></math> bestimmt. Dazu werden (<a href="#eq:winkelgeschwindigkeit">7</a>) und (<a href="#eq:winkelbeschleunigung">8</a>) angewandt.</p>
<h3 id="syntax-2">Syntax</h3>
<p><code>[phi_calc, omega_calc, alpha_calc] = my_ang(phi, option, t_)</code></p>
<h3 id="parameter-2">Parameter</h3>
<ul>
<li><code>phi</code> 3D-Vektor oder Cell mit 3 Vektorfunktionen der Eulerwinkel</li>
<li><code>option</code> String: <code>'num'</code> oder <code>'sym'</code> zur Auswahl für nummerische oder symbolische Berechnung</li>
<li><code>t_</code> 1D-Zeitvektor</li>
<li><code>phi_calc</code> berechneter 3D-Vektor für die Euler-Winkel (im nummerischen fall ident mit <code>s</code>)</li>
<li><code>omega_calc</code> berechneter 3D-Vektor für die Winkelgeschwindigkeit</li>
<li><code>alpha_calc</code> berechneter 3D-Vektor für die Winkelbeschleunigung</li>
</ul>
<h3 id="beispiel-2">Beispiel</h3>
<h4 id="nummerisch-1">Nummerisch</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb7-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb7-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb7-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb7-12" title="12">phix = <span class="fl">0</span> .* t; <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-13" title="13">phiy = <span class="fl">0</span> .* t; <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-14" title="14">phiz = <span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% rad</span></a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16">phi = [phix&#39;, phiy&#39;, phiz&#39;];</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="co">%% Berechnung Winkelgrößen</span></a>
<a class="sourceLine" id="cb7-19" title="19">[phi, omega, alpha] = my_ang(phi,&quot;num&quot;,t);</a></code></pre></div>
<h4 id="symbolisch-1">Symbolisch</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb8-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb8-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb8-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb8-12" title="12">phix = @(t) (<span class="fl">0.8</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-13" title="13">phiy = @(t) (<span class="fl">0.8</span> .* sin(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-14" title="14">phiz = @(t) (<span class="fl">0.3</span> .* cos(<span class="fl">2</span>*pi*f*t)); <span class="co">% m</span></a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">phi = {phix, phiy, phiz};</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="co">%% Berechnung Winkelgrößen</span></a>
<a class="sourceLine" id="cb8-19" title="19">[phi, omega, alpha] = my_ang(phi,&quot;sym&quot;,t);</a></code></pre></div>
<h2 id="rotation-my_rotate">Rotation <code>my_rotate</code></h2>
<p>Mit der Funktion <code>my_rotate</code> können Punkte oder Vektoren von einem Koordinatensystem (z.B. das Inertialsystem) in ein anderes Koordinatensystem (z.B. das Körperkoordinatensystem gedreht werden). Dazu wird (<a href="#eq:Drehmatrix">2</a>) und (<a href="#eq:Drehmatrix_rot1">3</a>) verwendet.</p>
<h3 id="syntax-3">Syntax</h3>
<p><code>[aB] = my_rotate(phi, aN, t)</code></p>
<h3 id="parameter-3">Parameter</h3>
<ul>
<li><code>phi</code> 3D-Vektor der Euler-Winkel (Orientierung zwischen Inertialsystem und Körperkoordinatensystem)</li>
<li><code>aN</code> 3D-Vektor im Inertialsystem</li>
<li><code>t</code> Zeit</li>
<li><code>aB</code> 3D-Vektor im Körperkoordinatensystem</li>
<li><code>phi_tx</code> 1D-Vektor für x-Komponente der Euler-Winkel</li>
</ul>
<h3 id="beispiel-3">Beispiel</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb9-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb9-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb9-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb9-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb9-17" title="17"></a>
<a class="sourceLine" id="cb9-18" title="18"><span class="co">%% Berechnung lineare Größen</span></a>
<a class="sourceLine" id="cb9-19" title="19">[s_N, v_N, a_N] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb9-20" title="20"><span class="co">% lineare Größen im Schwerpunkt S und referenzerit auf das Inertialsystem N</span></a>
<a class="sourceLine" id="cb9-21" title="21"></a>
<a class="sourceLine" id="cb9-22" title="22"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb9-23" title="23">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v_N, t);</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25">phi = [phi_tx, phi_ty, phi_tz];</a>
<a class="sourceLine" id="cb9-26" title="26"></a>
<a class="sourceLine" id="cb9-27" title="27"><span class="co">%% Rotation der lineare Beschleunigung</span></a>
<a class="sourceLine" id="cb9-28" title="28">[a_B] = my_rotate(phi, a_N, t); </a>
<a class="sourceLine" id="cb9-29" title="29"><span class="co">% lineare Beschleunigung im Schwerpunkt S und referenzerit auf das Körperkoorinatensystem B</span></a></code></pre></div>
<h2 id="imu-größen-my_imu">IMU Größen <code>my_imu</code></h2>
<p>Mit der Funktion <code>my_imu</code> können anhand der Größen im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> die Winkelgeschwindigkeit und die lineare Beschleunigung im Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> bestimmt werden. Dazu kann (<a href="#eq:kinematisch">9</a>) verwendet werden. Damit die Daten aus der Sicht der IMU bestimmt werden müssen Größen im Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> ins Körperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> gedreht werden. Dazu kann die Funktion <code>my_rot</code> verwendet werden.</p>
<h3 id="syntax-4">Syntax</h3>
<p><code>[aIMU] = my_imu(aB, omega, alpha, r, t)</code></p>
<h3 id="parameter-4">Parameter</h3>
<ul>
<li><code>aS</code> 3D-Vektor der linearen Beschleunigung im Körperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> am Schwerpunkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math></li>
<li><code>omega</code> 3D-Vektor der Winkelgeschwindigkeit</li>
<li><code>alpha</code> 3D-Vektor der Winkelbeschleunigung</li>
<li><code>r</code> Abstandsvektor zwischen Schwerpunkt und IMU</li>
<li><code>t</code> 1D-Vektor der Zeit</li>
<li><code>aIMU</code> 3D-Vektor der linearen Beschleunigung im Körperkoordinatensystem <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔹</mi></mstyle><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math> am Punkt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math></li>
</ul>
<h3 id="beispiel-4">Beispiel</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb10-1" title="1"><span class="co">%% Zeit</span></a>
<a class="sourceLine" id="cb10-2" title="2">t_start = <span class="fl">0</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-3" title="3">t_stop = <span class="fl">5</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-4" title="4">t_step = <span class="fl">0.005</span>; <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6">t = (t_start:t_step:t_stop); <span class="co">% s</span></a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">%% Frequenz</span></a>
<a class="sourceLine" id="cb10-9" title="9">f = <span class="fl">1</span>; <span class="co">% Hz</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="co">%% Trajektorie</span></a>
<a class="sourceLine" id="cb10-12" title="12">sx = <span class="fl">0.8</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-13" title="13">sy = <span class="fl">0.8</span> * <span class="fl">5</span> .* sin(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-14" title="14">sz = <span class="fl">0.3</span> * <span class="fl">5</span> .* cos(<span class="fl">2</span>*pi*f*t); <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16">s = [sx&#39;, sy&#39;, sz&#39;];</a>
<a class="sourceLine" id="cb10-17" title="17"></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="co">%% Position IMU</span></a>
<a class="sourceLine" id="cb10-19" title="19">r = [-<span class="fl">150e-3</span>,-<span class="fl">150e-3</span>,<span class="fl">50e-3</span>]./<span class="fl">2</span>; <span class="co">% m</span></a>
<a class="sourceLine" id="cb10-20" title="20"></a>
<a class="sourceLine" id="cb10-21" title="21"><span class="co">%% Berechnung lineare Größen</span></a>
<a class="sourceLine" id="cb10-22" title="22">[s_S_N, v_S_N, a_S_N] = my_lin(s,&quot;num&quot;,t);</a>
<a class="sourceLine" id="cb10-23" title="23"><span class="co">% lineare Größen im Schwerpunkt S und referenzerit auf das Inertialsystem N</span></a>
<a class="sourceLine" id="cb10-24" title="24"></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="co">%% Berechnung Tangentialwinkel</span></a>
<a class="sourceLine" id="cb10-26" title="26">[phi_tz, phi_ty, phi_tx, ta] = my_tang(v_S_N, t);</a>
<a class="sourceLine" id="cb10-27" title="27"></a>
<a class="sourceLine" id="cb10-28" title="28">phi = [phi_tx, phi_ty, phi_tz];</a>
<a class="sourceLine" id="cb10-29" title="29"></a>
<a class="sourceLine" id="cb10-30" title="30"><span class="co">%% Berechnung Wineklgrößen</span></a>
<a class="sourceLine" id="cb10-31" title="31">[phi, omega, alpha] = my_ang(phi,&quot;num&quot;,t); </a>
<a class="sourceLine" id="cb10-32" title="32"><span class="co">% Winkelgrößen des starren Körpers (sind am gesammten Körper ident)</span></a>
<a class="sourceLine" id="cb10-33" title="33"></a>
<a class="sourceLine" id="cb10-34" title="34"><span class="co">%% Rotation der lineare Beschleunigung</span></a>
<a class="sourceLine" id="cb10-35" title="35">[a_S_B] = my_rotate(phi, a_S_N, t); </a>
<a class="sourceLine" id="cb10-36" title="36"><span class="co">% lineare Beschleunigung im Schwerpunkt S und referenzerit auf das Körperkoorinatensystem B</span></a>
<a class="sourceLine" id="cb10-37" title="37"></a>
<a class="sourceLine" id="cb10-38" title="38"><span class="co">%% Berechnung IMU Daten</span></a>
<a class="sourceLine" id="cb10-39" title="39">[a_I_B] = my_imu(a_S_B, omega, alpha, r, t);</a>
<a class="sourceLine" id="cb10-40" title="40"></a>
<a class="sourceLine" id="cb10-41" title="41"><span class="co">% a_I_B entspricht gemessenen Beschleunigung der IMU</span></a>
<a class="sourceLine" id="cb10-42" title="42">a_IMU = a_I_B;</a>
<a class="sourceLine" id="cb10-43" title="43"><span class="co">% omega entspricht der gemessenen Winkelgeschwindigkeit der IMU</span></a>
<a class="sourceLine" id="cb10-44" title="44">omega_IMU = omega; </a></code></pre></div>

<h1 id="beispiele">Beispiele</h1>
</body>
</html>
